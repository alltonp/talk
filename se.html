<!-- Ghetto Slides. A basic slide deck for the lazy (like me).
     Feel free to copy, modify, rip-off, etc, but please credit me in the source somewhere.
     Joe Walnes, http://joewalnes.com -->

<!-- Added backwards navigation and not running off the end support.
     Paul Allton, paulallton@gmail.com -->

<!-- TODO:
   add mouse support back
-->

<!-- TIP
    http://htmlpreview.github.io/?https://raw.githubusercontent.com/alltonp/talk/master/se.html
-->

<!DOCTYPE HTML>
<html>
<head>
    <script src="js/jquery-1.4.3.min.js"></script>
    <style>
        body { color: #000000; background-color: #ffffff; font-family: arial; font-size: 50px; -webkit-user-select: none; }
        section { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; text-align: center; padding-top: 25px; }
        t1 { display: block; color: #428bca; font-size: 125%; padding-bottom: 20px;}
        t2 { color: #999; }
        pre { margin: 40px; text-align: left; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; color: #000000; background-color: #eee;font-size: 30px;border: 1px dashed #999999;padding: 5px 5px 5px 5px; overflow: auto; width: 90%; }
        img { float:centre; }
        li { margin: 25px; text-align: left;}
    </style>
    <script>
        $(function(event) {
        previous = function() {
        if (currentSection.prev().size() != 0) {
        currentSection = currentSection.fadeOut().prev().fadeIn();
        } else {
        currentSection.fadeOut();
        currentSection = $('sections').find('section').last().fadeIn();
        }
        return false;
        };

        next = function() {
        if (currentSection.next().size() != 0) {
        currentSection = currentSection.fadeOut().next().fadeIn();
        } else {
        currentSection.fadeOut();
        currentSection = $('sections').find('section').first().fadeIn();
        }
        };

        //hack right might mouse
        document.oncontextmenu = previous;

        var startAt = 0 //TODO: read from url?
        var currentSection = $('sections').find('section').eq(startAt).fadeIn();
        $('body').bind('click keypress', function(event) {
        if (event.which == '44' || event.which == '3') { // < or right mouse for previous
        previous();
        } else {
        next();
        }
        });
        });

    </script>
    <title>??? - ???</title>
</head>
<body oncontextmenu="return false;">
<!--<img style="float:right; margin: 30px 30px;" src="img/logo.png"/>-->
<sections>

    <section>
        <t1>problem #1</t1>
        <ul>
            <li>how do you support a suite of applications/services in production?
            <li>constraint: without touching it ...
        </ul>
        <!--
            what makes banks unique? - no access to production box, no logins to the app
            even though everything is fully TDD'd with rafts of acceptance tests, things still
            go wrong when you put it all together
        -->
    </section>

    <section>
        <t1>what could go wrong?</t1>

        <div style="float: left;">
            <ul>
            <li>good
            <ul>
        </div>
        <div style="float: right;">
            <ul dir="rtl">
            <li>bad
            <ul>
        </div>
        <!--
            business, no memory, disk space - there is already monitoring for that kind of thing
            we are interested in application/business things

            todays reports arrived and are valid
            trades all processed
            no trades have been rejected
            pricing engine is able to price
            connections to external systems working (pings)

            put the work check in front of each .. turn them into a url

            what does it mean for each check .. we have tests for this already in each app ..
            we dont want to repeat that, we just want to expose the assertions

        -->
    </section>

    <section>
        <!--
            we've got a test for that, but tests only run as part of building/deploying the app
        -->
        <t1>assert</t1>
        <!--
            asserts continue to disappoint me
            invariants, first class citizens, why not expose them
        -->
        <ul>
            <li>failed
            <li>not fulfilled their potential
            <li>why only in tests?
            <li>why hidden?
        </ul>
        <!-- I want them running all the time -->
        <!-- we have already written them in our unit/acceptance tests -->
        <!-- why only executed at testing time? -->
        <!-- what if we could run them all the time -->
        <!-- why not make an api? -->
        <!-- why not expose it via a restlike interface? -->
    </section>

    <section>
        <t1>check</t1>
        <pre>   GET /check/foo/exists/@id</pre>
        <t2>Success</t2>
        <pre>   {"failures":[]}</pre>

        <t2>Failure</t2>
        <!-- need to add a better failure message -->
        <pre>   {"failures":["foo failed"]}</pre>
    </section>

    <section>
        <t1>bring it all together</t1>
        <!--
            checks in a list on repeat = monitoring
            take the original list and url-ify them
            then use those actual probes in the probate demo
            (and then again use the same ones in the actions)
        -->

    </section>

    <section>
        <t1>probate demo</t1>
        <!-- need a mainly green set, with a single flip flopper -->
        <iframe width="90%" height="80%" frameborder="0" src="http://localhost:8473/"></iframe>
    </section>

    <section>
        <t1>problem #2</t1>
        <ul>
            <li>integration testing a suite of applications/services
            <li>... how do you know it works together?
        </ul>
        <!--
            here the scala compile helps us in some many ways
        -->
    </section>

    <section>
        <t1>diagram</t1>
    </section>

    <!-- TODO: split the url and body into two pre chunks -->

    <section>
        <t1>action</t1>
        <pre>   POST /action/create/foo     =>       {"in":[
                                          {"name":"x", "value:":"y"}
                                        ]}</pre>
        <t2>Success</t2>
        <pre>   {"failures":[], "returnValue": "12345"}  //optional</pre>

        <t2>Failure</t2>
        <!-- need to add a better failure message -->
        <pre>   {"failures":["foo failed"]}</pre>
    </section>

    <section>
        <t1>example actions</t1>
    </section>

    <!--
        bring it altogether
        its just a case of assembling tests out of endpooints in a script
        and running it against an environment
    -->

    <section>
        <t1>bring it all together</t1>
        <!-- checks, actions and an engine to run -->
    </section>

    <!-- TODO: colourise the id -->

    <section>
        <t1>example tests</t1>
        <pre>   @id <= create trade in:x => notional:123
   check trade booked in:y => @id
   check trade cleared in:clearing => @id </pre>
    </section>

    <!-- need to explain what this maps to ... -->

    <section>
        <t1>shoreditch demo</t1>
        <!-- need to make the text on this bigger -->
        <iframe width="90%" height="80%" frameborder="0" src="http://localhost:4253/"></iframe>
    </section>

    <!--
        may not get this far
    -->

    <section>
        <t1>problem #3,4,5 ...x</t1>
        <ul>
            <li>... how do you know it's quick enough?
            <li>... how do you know what your capacity is?
            <li>... how do you test long running workflows (i.e. days to execute, events T+x)?
            <li>... how do you break up a monolithic app into microservices?
        </ul>
    </section>

    <section>
        <t1>next  ....</t1>
    </section>

    <!-- its all the same, with checks and actions, it's just a case of assembling tests out of endpooints ->

</sections>
</body>
</html>
